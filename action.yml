name: "Sync Repository without workflow files"
description: "Sync a source repository to the current repository, creating a new branch without workflow files"
branding:
  icon: "git-branch"
  color: "blue"

inputs:
  source_repo:
    description: "Source repository in format 'owner/repo' (e.g., 'octocat/Hello-World')"
    required: true
  source_branch:
    description: "Source branch name"
    required: false
    default: "main"
  source_commit:
    description: "Source commit hash to sync up to (optional, defaults to latest)"
    required: false
  branch_prefix:
    description: 'Output branch name prefix (e.g., "synced")'
    required: false
    default: "synced"
  dry_run:
    description: "Dry run mode (no push)"
    required: false
    default: "false"
  git_user_name:
    description: "Git user name for commits"
    required: false
    default: "github-actions[bot]"
  git_user_email:
    description: "Git user email for commits"
    required: false
    default: "github-actions[bot]@users.noreply.github.com"
  fetch_token:
    description: "GitHub token for fetching from source repository (optional). Required if source_repo is private. If not specified, uses default GITHUB_TOKEN."
    required: false
  push_token:
    description: "GitHub token for pushing branches (optional). If not specified, uses default GITHUB_TOKEN."
    required: false

runs:
  using: "composite"
  steps:
    - name: Checkout current repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure Git
      shell: bash
      run: |
        git config user.name "${{ inputs.git_user_name }}"
        git config user.email "${{ inputs.git_user_email }}"

    - name: Validate source_repo format
      shell: bash
      run: |
        SOURCE_REPO="${{ inputs.source_repo }}"

        # Validate owner/repo format
        if [[ ! "$SOURCE_REPO" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
          echo "‚ùå Error: source_repo must be in format 'owner/repo' (e.g., 'octocat/Hello-World')"
          echo "   Received: $SOURCE_REPO"
          exit 1
        fi

    - name: Add upstream remote
      shell: bash
      run: |
        SOURCE_REPO="${{ inputs.source_repo }}"
        SOURCE_REPO_URL="https://github.com/${SOURCE_REPO}"

        echo "Adding upstream remote: $SOURCE_REPO_URL"
        git remote add upstream "$SOURCE_REPO_URL"

    - name: Fetch upstream changes
      shell: bash
      env:
        FETCH_TOKEN: ${{ inputs.fetch_token }}
      run: |
        # Configure fetch token if specified
        if [ -n "$FETCH_TOKEN" ]; then
          # Get current upstream remote URL
          ORIGINAL_UPSTREAM_URL=$(git remote get-url upstream)
          
          # Temporarily set upstream remote URL with token
          # This method is more reliable than url.insteadOf because it directly changes
          # the remote URL, which takes precedence over credential helper set by actions/checkout
          SOURCE_REPO="${{ inputs.source_repo }}"
          git remote set-url upstream "https://$FETCH_TOKEN@github.com/${SOURCE_REPO}.git"
          
          # Fetch using the token
          git fetch upstream
          
          # Restore original upstream remote URL
          git remote set-url upstream "$ORIGINAL_UPSTREAM_URL"
        else
          git fetch upstream
        fi

    - name: Create temporary branch
      id: create-branch
      shell: bash
      run: |
        # Create temporary branch name
        TEMP_BRANCH="temp-sync-${{ github.run_id }}"
        echo "Creating temporary branch: $TEMP_BRANCH"

        # Create temporary branch from source branch
        git checkout -b "$TEMP_BRANCH" "upstream/${{ inputs.source_branch }}"

        echo "Temporary branch $TEMP_BRANCH created successfully"
        echo "temp_branch_name=$TEMP_BRANCH" >> $GITHUB_OUTPUT
        echo "branch_exists=false" >> $GITHUB_OUTPUT

    - name: Reset to source commit
      if: steps.create-branch.outputs.branch_exists != 'true' && inputs.source_commit != ''
      shell: bash
      run: |
        # Check if source commit exists
        echo "Checking if source commit exists: ${{ inputs.source_commit }}"
        if ! git rev-parse --verify "${{ inputs.source_commit }}" >/dev/null 2>&1; then
          echo "‚ùå Error: Source commit ${{ inputs.source_commit }} does not exist"
          exit 1
        fi

        # Reset to source commit
        echo "Resetting to source commit: ${{ inputs.source_commit }}"
        git reset --hard "${{ inputs.source_commit }}"
        echo "Successfully reset to commit: ${{ inputs.source_commit }}"

    - name: Create final branch
      id: create-final-branch
      if: steps.create-branch.outputs.branch_exists != 'true'
      shell: bash
      run: |
        # Get current commit hash (6 characters)
        CURRENT_COMMIT=$(git rev-parse --short=6 HEAD)
        echo "Current commit hash: $CURRENT_COMMIT"

        # Generate final branch name
        FINAL_BRANCH="${{ inputs.branch_prefix }}-$CURRENT_COMMIT"
        echo "Final branch name: $FINAL_BRANCH"

        # Skip if branch already exists
        if git show-ref --verify --quiet refs/heads/$FINAL_BRANCH; then
          echo "Branch $FINAL_BRANCH already exists, skipping creation"
          echo "branch_exists=true" >> $GITHUB_OUTPUT
          echo "final_branch_name=$FINAL_BRANCH" >> $GITHUB_OUTPUT
        else
          # Create final branch from temporary branch
          git checkout -b "$FINAL_BRANCH"
          echo "Final branch $FINAL_BRANCH created successfully"
          echo "branch_exists=false" >> $GITHUB_OUTPUT
          echo "final_branch_name=$FINAL_BRANCH" >> $GITHUB_OUTPUT
        fi

    - name: Remove workflow files
      if: steps.create-branch.outputs.branch_exists != 'true'
      shell: bash
      run: |
        # Remove .github/workflows/ directory if it exists
        # This is necessary because GitHub Actions does not allow workflows to be pushed by GitHub Actions
        # to prevent recursive workflow triggers and security issues
        if [ -d ".github/workflows" ]; then
          echo "Removing .github/workflows/ directory"
          rm -rf .github/workflows
          git add -A
          git commit -m "Remove workflow files from synced branch" || echo "No changes to commit"
          echo "Removed .github/workflows/ directory"
        else
          echo ".github/workflows/ directory does not exist, skipping removal"
        fi

    - name: Push branch
      if: steps.create-branch.outputs.branch_exists != 'true' && inputs.dry_run != 'true'
      shell: bash
      env:
        PUSH_TOKEN: ${{ inputs.push_token }}
      run: |
        FINAL_BRANCH="${{ steps.create-final-branch.outputs.final_branch_name }}"
        echo "üì§ Pushing branch $FINAL_BRANCH to origin..."

        # Configure push token if specified
        if [ -n "$PUSH_TOKEN" ]; then
          # Get current remote URL
          ORIGINAL_URL=$(git remote get-url origin)
          
          # Temporarily set remote URL with token
          # This method is more reliable than url.insteadOf because it directly changes
          # the remote URL, which takes precedence over credential helper set by actions/checkout
          git remote set-url origin "https://$PUSH_TOKEN@github.com/${GITHUB_REPOSITORY}.git"
          
          # Push using the token
          git push origin "$FINAL_BRANCH"
          
          # Restore original remote URL
          git remote set-url origin "$ORIGINAL_URL"
        else
          git push origin "$FINAL_BRANCH"
        fi

        echo "‚úÖ Successfully pushed branch: $FINAL_BRANCH"

    - name: Display logs
      shell: bash
      run: |
        FINAL_BRANCH="${{ steps.create-final-branch.outputs.final_branch_name }}"

        if [ "${{ steps.create-branch.outputs.branch_exists }}" = "true" ]; then
          echo "‚ÑπÔ∏è  Branch $FINAL_BRANCH already exists - skipping all operations"
        elif [ "${{ inputs.dry_run }}" = "true" ]; then
          echo "üîç DRY RUN MODE - Would push to origin/$FINAL_BRANCH"
        else
          echo "‚úÖ Sync operation completed successfully"
        fi
